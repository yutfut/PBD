### 1. Каковы возможности программирования на стороне сервера с применением SQL\PSM?\
   Перечень возможностей стандарта PSM выглядит следующим образом:\
   • объявление и использование переменных,\
   • возврат значений,\
   • условия,\
   • циклы,\
   • работа с курсором,\
   • перехват, обработка и вызов исключений,\
   • вызов системных функций,\
   • DML и DDL команды языка SQL,\
   • динамические запросы.\
   В PostgreSQL можно программировать на нескольких языках, в том числе на PL/pgSQL\
   В языках программирования обычно имеется два типа подпрограмм:\
   • хранимые процедуры;\
   • определяемые пользователем функции (UDF).
### 2. Хранимые процедуры и функции (скалярные, in-line). Их синтаксис и способы вызова. Передача параметров. Параметры по умолчанию.
> Функция является скалярной, если предложение RETURNS определяет один из скалярных типов данных и возвращает в качестве ответа единственное значение при каждом вызове функции.

```sql
create or replace function function_name(value_name value_type)
returns returns_type as 'select count(*) into yet_value ...;'
language plpgsql;
```

```sql
create or replace function function_name(value_name value_type)
returns returns_type as
$$
declare yet_value integer;
begin
    select count(*) into yet_value ...;
    return yet_value;
end
$$
language plpgsql;
```

Параметры по умолчанию
```sql
create or replace function function_name(value int default 1)...
```

>Если тело функции является одним SQL-запросом, то такая функция называется встроенной («inline»).

```sql
create or replace function function_name(value_name value_type)
returns table(col1, col2) as
$$
       select col1, col2 from ...;
$$
language sql;
```

>Параметры по умолчанию.

```sql 
create function foo(x integer default 1)
```

### 3. Конструкции языка SQL-PSM: условие, перехват исключений, создание исключений, присваивание переменных.

```sql 
условие
if
    $$
else
    $$
end if;
```

```sql
перехват исключений
exception when others then RAISE NOTICE 'перехватили ошибку';
```

```sql
создание иселючений
if usern is NULL then
    raise exception using errcode='E0001', hint='error', message='error';
end if;
```

```sql
присваивание переменных
переменная := выражение
             -- ИЛИ 
переменная = выражение;
```

### 4. Использование курсора.

Вместо того чтобы сразу выполнять весь запрос, есть возможность настроить курсор, инкапсулирующий запрос, и затем получать результат запроса по нескольку строк за раз. Одна из причин так делать заключается в том, чтобы избежать переполнения памяти, когда результат содержит большое количество строк.

```sql
DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;
```

### 5. Синтаксис и процесс выполнения рекурсивных запросов.

В рекурсивной части CTE обязательно должна быть стартовая часть и рекурсивная часть, разделенные словом UNION.\

https://habr.com/ru/articles/269497/

```sql
WITH RECURSIVE r AS (
    -- стартовая часть рекурсии
    SELECT 
        1 AS i, 
        1 AS factorial
    
    UNION 
    
    -- рекурсивная часть 
    SELECT 
        i+1 AS i, 
        factorial * (i+1) as factorial 
    FROM r
    WHERE i < 10
)
SELECT * FROM r;

 i  | factorial 
----+-----------
  1 |         1
  2 |         2
  3 |         6
  4 |        24
  5 |       120
  6 |       720
  7 |      5040
  8 |     40320
  9 |    362880
 10 |   3628800
(10 rows)
```

### 6. Синтаксис и назначение ранжирующих функций.
Оконная функция выполняет вычисления для набора строк, некоторым образом связанных с текущей строкой. Можно сравнить её с агрегатной функцией, но, в отличие от обычной агрегатной функции, при использовании оконной функции несколько строк не группируются в одну, а продолжают существовать отдельно.

```sql
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;

  depname  | empno | salary |          avg          
-----------+-------+--------+-----------------------
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel |     5 |   3500 | 3700.0000000000000000
 personnel |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
```

### 7. Постреляционные возможности языка SQL.
### 8. Как создать, собрать, присоединить и вызвать функцию агрегат? Каковы ее методы?
Агрегатная функция вызывается для каждой строки таблицы по очереди и в конечном итоге обрабатывает их все. Между вызовами ей требуется сохранять внутреннее состояние, определяющее контекст ее выполнения. В конце работы она должна вернуть итоговое значение.
### 9. Что такое DML триггер, как и когда он запускается и как его создать? Как из триггера определить изменяемые данные?
Триггеры PL/SQL уровня команд DML активизируются после вставки, обновления или удаления строк конкретной таблиц.
Триггер можно настроить так, чтобы он срабатывал до операции со строкой или после её завершения, либо вместо операции.
### 10. Что такое динамические запросы? Как их выполнять?
Динамические запросы — это запросы, текст которых формируется во время выполнения приложения и заранее не компилируется.

```sql
EXECUTE format('delete from lab2.users where username = %I;', usern);
```

```sql
execute 'select * from table where id = $1' into a using 1;
```

### 11. Что такое обновляемое представление? Каковы его свойства? Как необновляемое представление сделать обновляемым?



### 12. Что такое DDL триггер, как и когда он запускается и как его создать? Как из триггера определить возникшее событие и его параметры?
Триггеры DDL активируются в ответ на различные события языка DDL. Эти события в основном соответствуют инструкциям SQL/PSM, которые начинаются с ключевых слов CREATE, ALTER, DROP, GRANT, DENY, REVOKE или UPDATE STATISTICS. Системные хранимые процедуры, выполняющие операции, подобные операциям DDL, также могут запускать триггеры DDL.\
Используйте триггеры DDL, если хотите сделать следующее.\
• Предотвращать внесение определенных изменений в схему базы данных.\
• Настроить выполнение в базе данных некоторых действий в ответ на изменения в схеме базы данных.\
• Записывать изменения или события схемы базы данных.